#version 450
#extension GL_ARB_separate_shader_objects : enable

// ============================================================
//  Culling Toggles
//  Uncomment or define via build system to enable specific tests
// ============================================================
// #define ENABLE_ORIENTATION_CULL
// #define ENABLE_FRUSTUM_CULL
// #define ENABLE_DISTANCE_CULL
// ============================================================

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// set = 0 : camera
layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
} camera;

// set = 1 : time
layout(set = 1, binding = 0) uniform TimeUBO {
    float dt;
    float t;
} timeUBO;

// Storage layout for blades and the draw-indirect counter
struct Blade {
    vec4 p0;  // xyz = v0, w = orientation
    vec4 p1;  // xyz = v1, w = height
    vec4 p2;  // xyz = v2, w = width
    vec4 up;  // xyz = up, w = stiffness
};

// set = 2 : storage buffers
layout(set = 2, binding = 0, std430) buffer InBladesSSBO {
    Blade data[];
} inputBlades;

layout(set = 2, binding = 1, std430) buffer VisibleBladesSSBO {
    Blade data[];
} outputBlades;

layout(set = 2, binding = 2, std430) buffer DrawIndirectSSBO {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
} drawCmd;

// ============================================================
// Helper Functions
// ============================================================

vec3 cameraPosition()
{
    return inverse(camera.view)[3].xyz;
}

vec3 frontDir(vec3 upN, float orientation)
{
    vec3 t1 = normalize(vec3(-cos(orientation), 0.0, sin(orientation)));
    return normalize(cross(t1, upN));
}

vec3 windField(vec3 rootPos, vec3 upN, float tNow)
{
    vec3 base = normalize(vec3(0.8, 0.0, 0.6));
    base -= upN * dot(base, upN);
    base = normalize(base + 1e-6);

    vec3 span = normalize(cross(upN, base));

    float phase1 = dot(rootPos.xz, vec2(12.9898, 78.233));
    float phase2 = dot(rootPos.xz, vec2(-41.425, 19.173));
    float w1 = 1.10 + 0.20 * sin(dot(rootPos.xz, vec2(0.015, 0.021)));
    float w2 = 0.95 + 0.15 * cos(dot(rootPos.xz, vec2(-0.018, 0.014)));

    float s1 = sin(tNow * w1 + phase1);
    float s2 = cos(tNow * w2 + phase2);
    float lift = 0.05 * sin(tNow * 0.35 + phase2 * 0.7);

    vec3 dir = base + span * (0.85 * s1 + 0.90 * s2) + upN * lift;
    return normalize(dir);
}

bool frustumOutside(vec3 wp)
{
    vec4 clip = camera.proj * camera.view * vec4(wp, 1.0);
    float w = clip.w + 0.15;
    return (clip.x >  w || clip.x < -w ||
            clip.y >  w || clip.y < -w ||
            clip.z >  w || clip.z < -w);
}

float hash01(vec2 p)
{
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

bool distanceCull(vec3 camPos, vec3 root, float maxDist, uint buckets)
{
    vec3 upCam = root - camPos;
    float dist = length(upCam - normalize(upCam) * dot(upCam, vec3(0)));
    if (dist > maxDist) return true;

    uint b = uint(clamp(floor(dist / maxDist * float(buckets)), 0.0, float(buckets - 1)));
    float keep = 1.0 - (float(b) + 0.5) / float(buckets);
    float h = hash01(root.xz);
    return (h > keep);
}

// ============================================================
// Main Simulation + Culling
// ============================================================

void main()
{
    uint i = gl_GlobalInvocationID.x;

    if (i == 0u) {
        drawCmd.vertexCount   = 0u;
        drawCmd.instanceCount = 1u;
        drawCmd.firstVertex   = 0u;
        drawCmd.firstInstance = 0u;
    }
    barrier();

    Blade b = inputBlades.data[i];

    float orient   = b.p0.w;
    float height   = b.p1.w;
    float width    = b.p2.w;
    float stiff    = b.up.w;

    vec3 upN = normalize(b.up.xyz);
    vec3 v0  = b.p0.xyz;
    vec3 v1  = b.p1.xyz;
    vec3 v2  = b.p2.xyz;

    // --- Forces ---
    vec3 gEnv = normalize(vec3(0.0, -1.0, 0.0)) * 9.81;
    vec3 fDir = frontDir(upN, orient);
    vec3 gF   = 0.25 * length(gEnv) * fDir;
    vec3 gAcc = gEnv + gF;

    vec3 v2Rest = v0 + upN * height;
    vec3 rec    = (v2Rest - v2) * stiff;

    vec3 wDir   = windField(v0, upN, timeUBO.t);
    vec3 axis   = normalize(v2 - v0);
    float align = max(dot(axis, wDir), 0.0);
    vec3 wind   = wDir * (4.0 * align);

    vec3 dv2 = (gAcc + rec + wind) * timeUBO.dt;
    v2 += dv2;

    float below = min(dot(upN, v2 - v0), 0.0);
    v2 -= upN * below;

    vec3 lateral = v2 - v0 - upN * dot(upN, v2 - v0);
    float lateralLen = length(lateral);

    float k = clamp(1.0 - lateralLen / height, 0.05, 1.0);
    v1 = v0 + upN * height * k;

    float L0 = length(v2 - v0);
    float L1 = length(v1 - v0) + length(v2 - v1);
    float L  = (2.0 * L0 + L1) / 3.0;
    float r  = height / max(L, 1e-6);
    vec3 v1c = v0 + r * (v1 - v0);
    v2 = v1c + r * (v2 - v1);
    v1 = v1c;

    b.p1.xyz = v1;
    b.p2.xyz = v2;
    inputBlades.data[i] = b;

    // ============================================================
    // Culling (conditionally compiled)
    // ============================================================

    vec3 camPos = cameraPosition();

#ifdef ENABLE_ORIENTATION_CULL
    vec3 toCam   = v0 - camPos;
    vec3 viewPrj = normalize(toCam - upN * dot(toCam, upN));
    vec3 widthAxis = normalize(vec3(-cos(orient), 0.0, sin(orient)));
    float facing = abs(dot(widthAxis, viewPrj));
    if (facing < 0.9) return;
#endif

#ifdef ENABLE_FRUSTUM_CULL
    vec3 m = 0.25 * v0 + 0.5 * v1 + 0.25 * v2;
    if (frustumOutside(v0) && frustumOutside(v2) && frustumOutside(m)) return;
#endif

#ifdef ENABLE_DISTANCE_CULL
    if (distanceCull(camPos, v0, 48.0, 8u)) return;
#endif

    // ============================================================
    // Output visible blades
    // ============================================================
    uint outIndex = atomicAdd(drawCmd.vertexCount, 1u);
    outputBlades.data[outIndex] = b;
}
