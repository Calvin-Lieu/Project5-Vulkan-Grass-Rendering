#version 450
#extension GL_ARB_separate_shader_objects : enable

// ==========================================================
// TOGGLES
// ==========================================================
#define ENABLE_ORIENTATION_CULL 0
#define ENABLE_FRUSTUM_CULL     1
#define ENABLE_DISTANCE_CULL    0

// Distance culling params, lower dist_max => more aggressive culling
#define DIST_MAX      20.0
#define DIST_BUCKETS  8u

// Orientation threshold tau
#define ORIENT_THRESHOLD 0.9

// Frustum tolerance t. Vulkan clip uses z in [0, w].
#define FRUSTUM_TOLERANCE 0.01

// ==========================================================
// WORKGROUP SIZE
// ==========================================================
layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// ==========================================================
// CAMERA + TIME BUFFERS
// ==========================================================
layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
} camera;

layout(set = 1, binding = 0) uniform TimeUBO {
    float dt;
    float t;
} timeUBO;

// ==========================================================
// STRUCTURE DEFINITIONS
// ==========================================================
struct Blade {
    vec4 p0;  // xyz = root (v0), w = orientation
    vec4 p1;  // xyz = mid  (v1), w = height
    vec4 p2;  // xyz = tip  (v2), w = width
    vec4 up;  // xyz = up,  w = stiffness
};

layout(set = 2, binding = 0, std430) buffer InBladesSSBO {
    Blade data[];
} inputBlades;

layout(set = 2, binding = 1, std430) buffer VisibleBladesSSBO {
    Blade data[];
} outputBlades;

layout(set = 2, binding = 2, std430) buffer DrawIndirectSSBO {
    // Matches VkDrawIndirectCommand
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
} drawCmd;

// ==========================================================
// HELPERS
// ==========================================================
vec3 cameraPosition()
{
    // view = [ R  t ; 0 1 ], camPos = inverse(view)[3].xyz
    return inverse(camera.view)[3].xyz;
}

// Width-axis based on blade orientation in ground plane
vec3 bladeWidthAxis(float orientation)
{
    return normalize(vec3(-cos(orientation), 0.0, sin(orientation)));
}

vec3 frontDir(vec3 upN, float orientation)
{
    vec3 t1 = bladeWidthAxis(orientation);
    return normalize(cross(t1, upN));
}

vec3 windField(vec3 rootPos, vec3 upN, float tNow)
{
    vec3 base = normalize(vec3(0.8, 0.0, 0.6));
    base -= upN * dot(base, upN);
    base = normalize(base + 1e-6);

    vec3 span = normalize(cross(upN, base));

    float phase1 = dot(rootPos.xz, vec2(12.9898, 78.233));
    float phase2 = dot(rootPos.xz, vec2(-41.425, 19.173));
    float w1 = 1.10 + 0.20 * sin(dot(rootPos.xz, vec2(0.015, 0.021)));
    float w2 = 0.95 + 0.15 * cos(dot(rootPos.xz, vec2(-0.018, 0.014)));

    float s1 = sin(tNow * w1 + phase1);
    float s2 = cos(tNow * w2 + phase2);
    float lift = 0.05 * sin(tNow * 0.35 + phase2 * 0.7);

    vec3 dir = base + span * (0.85 * s1 + 0.90 * s2) + upN * lift;
    return normalize(dir);
}

// Vulkan clip: z in [0, w]
bool insideFrustumWithTolerance(vec3 wp, float tol)
{
    vec4 clip = camera.proj * camera.view * vec4(wp, 1.0);
    if (clip.w <= 0.0) return false;

    vec3 ndc = clip.xyz / clip.w;
    return abs(ndc.x) <= 1.0 + tol &&
           abs(ndc.y) <= 1.0 + tol &&
           ndc.z >= 0.0 - tol && ndc.z <= 1.0 + tol;
}

// ==========================================================
// MAIN
// ==========================================================
void main()
{
    uint i = gl_GlobalInvocationID.x;

    // Reset indirect args once per dispatch
    if (i == 0u) {
        drawCmd.vertexCount   = 0u;
        drawCmd.instanceCount = 1u;
        drawCmd.firstVertex   = 0u;
        drawCmd.firstInstance = 0u;
    }
    // Ensure reset is visible to the workgroup
    memoryBarrierBuffer();
    barrier();

    Blade b = inputBlades.data[i];

    float orient   = b.p0.w;
    float height   = b.p1.w;
    float width    = b.p2.w;
    float stiff    = b.up.w;

    vec3 upN = normalize(b.up.xyz);
    vec3 v0  = b.p0.xyz;
    vec3 v1  = b.p1.xyz;
    vec3 v2  = b.p2.xyz;

    // ======================================================
    // PHYSICS 
    // ======================================================
    vec3 gEnv = normalize(vec3(0.0, -1.0, 0.0)) * 9.81;
    vec3 fDir = frontDir(upN, orient);
    vec3 gF   = 0.25 * length(gEnv) * fDir;
    vec3 gAcc = gEnv + gF;

    vec3 v2Rest = v0 + upN * height;
    vec3 rec    = (v2Rest - v2) * stiff;

    vec3 wDir   = windField(v0, upN, timeUBO.t);
    vec3 axis   = normalize(v2 - v0);
    float align = max(dot(axis, wDir), 0.0);
    vec3 wind   = wDir * (4.0 * align);

    vec3 dv2 = (gAcc + rec + wind) * timeUBO.dt;
    v2 += dv2;

    // State correction
    float below = min(dot(upN, v2 - v0), 0.0);
    v2 -= upN * below;

    vec3 lateral = v2 - v0 - upN * dot(upN, v2 - v0);
    float lateralLen = length(lateral);
    float k = clamp(1.0 - lateralLen / height, 0.05, 1.0);
    v1 = v0 + upN * height * k;

    float L0 = length(v2 - v0);
    float L1 = length(v1 - v0) + length(v2 - v1);
    float L  = (2.0 * L0 + L1) / 3.0;
    float r  = height / max(L, 1e-6);
    vec3 v1c = v0 + r * (v1 - v0);
    v2 = v1c + r * (v2 - v1);
    v1 = v1c;

    // Write back simulation state
    b.p1.xyz = v1;
    b.p2.xyz = v2;
    inputBlades.data[i] = b;

    // ======================================================
    // CULLING 
    // ======================================================
    vec3 camPos = cameraPosition();

#if ENABLE_ORIENTATION_CULL
    {
        // dirc: camera view direction from blade toward camera
        vec3 dirc = normalize(camPos - v0);
        // dirb: blade width axis
        vec3 dirb = bladeWidthAxis(orient);
        // Cull if |dot| > tau (near parallel to view direction)
        if (abs(dot(dirc, dirb)) < ORIENT_THRESHOLD)
            return;
    }
#endif

#if ENABLE_FRUSTUM_CULL
    {
        // Test v0, v2, and Bezier midpoint m = 1/4 v0 + 1/2 v1 + 1/4 v2
        vec3 m = 0.25 * v0 + 0.5 * v1 + 0.25 * v2;
        bool in0 = insideFrustumWithTolerance(v0, FRUSTUM_TOLERANCE);
        bool in1 = insideFrustumWithTolerance(m,  FRUSTUM_TOLERANCE);
        bool in2 = insideFrustumWithTolerance(v2, FRUSTUM_TOLERANCE);
        if (!in0 && !in1 && !in2)
            return;
    }
#endif

#if ENABLE_DISTANCE_CULL
    {
        // Projected distance onto plane orthogonal to up (paper Eq. 19)
        vec3 toCam = v0 - camPos;
        float d_proj = length(toCam - upN * dot(toCam, upN));

        // Quantize into buckets up to DIST_MAX (Eqs. 19-20)
        float u = clamp(d_proj / DIST_MAX, 0.0, 1.0);
        uint level = uint(floor(u * float(DIST_BUCKETS)));

        // Keep 1/DIST_BUCKETS of blades in nearest bucket,
        // 2/DIST_BUCKETS in next, etc. using index mod pattern.
        if (i % DIST_BUCKETS < level)
            return;
    }
#endif

    // ======================================================
    // APPEND VISIBLE
    // ======================================================
    uint outIndex = atomicAdd(drawCmd.vertexCount, 1u);
    outputBlades.data[outIndex] = b;
}
